# 为什么逐渐加入多线程特性

### 举个例子

正常情况下使用 del 指令可以很快的删除数据，而当被删除的 key 是一个非常大的对象时，例如key包含了成千上万个元素的 hash 集合时，那么 del 指令就会造成 Redis 主线程卡顿。

$\textcolor{red}{\large 这就是redis3.x单线程时代最经典的故障，大key删除的头疼问题，}$由于redis是单线程的，del bigKey .....

等待很久这个线程才会释放，类似加了一个synchronized锁，你可以想象高并发下，程序堵成什么样子?

### 案例

比如当我(Redis)需要删除一个很大的数据时，因为是单线程原子命令操作，这就会导致 Redis 服务卡顿，于是在 Redis 4.0 中就新增了多线程的模块，当然此版本中的多线程主要是为了解决删除数据效率比较低的问题的。

| unlink key            |
| --------------------- |
| flushdb async         |
| flushall async        |
| 把删除工作交给了后台的子线程异步删除数据了 |









