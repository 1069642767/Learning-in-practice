当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据(对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来)。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞(当然，是进程自己选择的阻塞)。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kermel返回结果，用户进程才解除block的状态，重新运行起来。所以，<font color = 'red'>BIO的特点就是在IO执的两个阶段都被block了。</font>

![](images/3.BIO.png)

### 先演示accept

accept监听是典型的阻塞式监听

```Java
package com.luojia.redislock.iomultiplex.bio.accept;

import cn.hutool.core.util.IdUtil;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;

public class RedisServer {

    public static void main(String[] args) throws IOException {
        ServerSocket serverSocket = new ServerSocket(6379);

        while (true) {
            System.out.println("模拟RedisServer启动-----111 等待连接");
            // 没有监听到数据的情况下，会一直卡在这里
            Socket accept = serverSocket.accept();
            System.out.println("-----111 连接成功： " + IdUtil.simpleUUID());
            System.out.println();
        }
    }
}
```

```java
package com.luojia.redislock.iomultiplex.bio.accept;

import java.io.IOException;
import java.net.Socket;

public class RedisClient01 {
    public static void main(String[] args) throws IOException {
        System.out.println("---------RedisClient01 start");
        Socket socket = new Socket("127.0.0.1", 6379);
        System.out.println("---------RedisClient01 over");
    }
}
```

```java
package com.luojia.redislock.iomultiplex.bio.accept;

import java.io.IOException;
import java.net.Socket;

public class RedisClient02 {

    public static void main(String[] args) throws IOException {
        System.out.println("---------RedisClient02 start");
        Socket socket = new Socket("127.0.0.1", 6379);
        System.out.println("---------RedisClient02 over");
    }
}
```













