# 数据库和缓存一致性的几种更新策略

### 目的：总之，我们要达到最终一致性

<font color = blue>给缓存设置过期时间，定期清理缓存并回写，是保证最终一致性的解决方案。</font>

我们可以对存入缓存的数据设置过期时间，所有的<font color = gree>写操作以数据库为准</font>，对缓存操作只是尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存，达到一致性，<font color = gree>切记，要以mysql的数据库写入库为准</font>。

上述方案和后续落地案例是调研后的主流＋成熟的做法，但是考虑到各个公司业务系统的差距，<font color = red>不是100%绝对正确，不保证绝对适配全部情况</font>，需要自己酌情选择打法，合适自己的最好。

### <font color = green>可以停机的情况</font>

挂牌报错，凌晨升级，温馨提示，服务降级

单线程，这样重量级的数据操作最好不要多线程

### <font color = green>我们讨论4种更新策略</font>

1. <font color = red size = 10>× </font>先更新数据库，在更新缓存

   异常问题1

   ```text
   1 先更新mysql的某商品的库存，当前商品的库存是100，更新为99个。
   2 先更新mysql修改为99成功，然后更新redis。
   3 此时假设异常出现，更新redis失败了，这导致mysql里面的库存是99而redis里面的还是100。
   4 上述发生，会让数据库里面和缓存redis里面数据不一致，读到redis脏数据
   ```

   异常问题2

   ```text
   【先更新数据库，再更新缓存】﹐A、B两个线程发起调用
   【正常逻辑】
   1 A update mysql 100
   2 A update redis 100
   3 B update mysql 8o
   4 B update redis 8o
   =============================
   【异常逻辑】
   多线程环境下，A、B两个线程有快有慢，有前有后有并行
   1 A update mysql 100
   3 B update mysql 80
   4 B update redis 80
   2 A update redis 100
   =============================
   最终结果，mysql和lredis数据不一致，o(一_T)o，
   mysql80,redis100
   ```

2. <font color = red size = 10>× </font>先更新缓存，再更新数据库

   <font color = red size = 6>× </font>不推荐，业务上一般把MySQL作为<font color = red>底单数据库 </font>，保证最后解释

   ```text
   [先更新缓存，再更新数据库]，A、B两个线程发起调用
   [正常逻辑]
   1 A update redis 100
   2 A update mysql 100
   3 B update redis 80
   4 B update mysql 80
   ====================================
   [异常逻辑]多线程环境下，A. B两个线程有快有慢有并行
   A update redis 100
   B update redis 80
   B update mysq| 80
   A update mysql 100
   mysql100,redis80
   ```

3. 







