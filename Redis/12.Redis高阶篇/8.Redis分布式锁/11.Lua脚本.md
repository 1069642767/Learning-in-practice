### 加锁Lua脚本lock

- 先判断redis分布式锁这个key是否存在

  EXISTS key：

  ​	返回零说明不存在，hset新建当前线程属于自己的锁，field key格式为UUID:ThreadID，value为加锁次数；

  ​	返回壹说明已经有锁，需进一步判断是不是当前线程自己的 -> 

  ​	HEXISTS key uuid:ThreadID：返回0说明不是自己的锁；返回1说明是自己的锁，自增1次表示重入

  ​	HINCRBY key UUID:ThreadID 1

- 上述设计修改为Lua脚本

  v1版本

  ```lua
  // 加锁的Lua脚本，对标我们的lock方法
  if redis.call('exists', 'key') == 0 then
  	redis.call('hset', 'key', 'uuid:threadid', 1)
  	redis.call('expire', 'key', 50)
  	return 1
  elseif redis.call('hexists', 'key', 'uuid:threadid') == 1 then
  	redis.call('hincrby', 'key', 'uuid:threadid', 1)
  	redis.call('expire', 'key', 50)
  	return 1
  else
  	retuen 0
  end
  ```

  

  

- 测试































