### 二叉排序树

**二叉排序树**：BST: (Binary Sort(Search) Tree), 对于二叉排序树的**任何一个非叶子节点**，要求**左子节点的值比当前节点的值小**，**右子节点的值比当前节点的值大**。 

**特别说明**：如果有相同的值，可以将该节点放在左子节点或右子节点比如针对前面的数据 (7, 3, 10, 12, 5, 1, 9) ，对应的二叉排序树为：

![二叉排序树](images/二叉排序树.jpg)

#### 二叉排序树创建和遍历

一个数组创建成对应的二叉排序树，并使用中序遍历二叉排序树，比如: 数组为Array(7, 3, 10, 12, 5, 1, 9) ， 创建成对应的二叉排序树为 :

![二叉排序树创建和遍历](images/二叉排序树创建和遍历.jpg)

#### 二叉排序树的删除 

二叉排序树的删除情况比较复杂，有下面三种情况需要考虑 

1) **删除叶子节点** (比如：2, 5, 9, 12) 

2) 删除**只有一颗子树的节点** (比如：1) 

3) 删除**有两颗子树的节点**. (比如：7, 3，10 ) 

4) 操作的思路分析

![二叉排序树删除示意图](images/二叉排序树删除示意图.jpg)

//对删除结点的各种情况的思路分析: 

第一种情况: 删除叶子节点 (比如：2, 5, 9, 12) 

思路

(1) 需求先去找到要删除的结点 targetNode 

(2) 找到 targetNode 的 父结点 parent 

(3) 确定 targetNode 是 parent 的左子结点 还是右子结点 

(4) 根据前面的情况来对应删除 左子结点 parent.left = null 右子结点 parent.right = null; 

第二种情况: 删除只有一颗子树的节点 比如 1 

思路

(1) 需求先去找到要删除的结点 targetNode 

(2) 找到 targetNode 的 父结点 parent 

(3) 确定 targetNode 的子结点是左子结点还是右子结点 

(4) targetNode 是 parent 的左子结点还是右子结点 

(5) 如果 targetNode 有左子结点 

5. 1 如果 targetNode 是 parent 的左子结点parent.left = targetNode.left; 

   5.2 如果 targetNode 是 parent 的右子结点 parent.right = targetNode.left; 

(6) 如果 targetNode 有右子结点 

6.1 如果 targetNode 是 parent 的左子结点 parent.left = targetNode.right; 

6.2 如果 targetNode 是 parent 的右子结点 parent.right = targetNode.right

第三种情况 ： 删除有两颗子树的节点. (比如：7, 3，10 ) 

思路

(1) 需求先去找到要删除的结点 targetNode 

(2) 找到 targetNode 的 父结点 parent 

(3) 从 targetNode 的右子树找到最小的结点 

(4) 用一个临时变量，将 最小结点的值保存 temp = 11 

(5) 删除该最小结点 

(6) targetNode.value = temp 





