# 1.获得结果和触发计算

### 获得结果

#### public T get()

不见不散，一直等到结果才返回，会一直阻塞

#### public T get(long timeout, TimeUnit unit)

过时不候，在指定的timeout时间范围内可以正常返回，超过timeout时间，会报异常

#### public T join()

作用和get()方法一致，只是不抛出异常

#### public T getNow(T valueIfAbsent)

在异步线程计算还未完成的情况下，直接将入参返回，即：

计算完，返回计算完成后的结果；没算完，返回设定的valueIfAbsent值

### 主动触发计算

#### public boolean complete(T value) 

是否打断get方法立即返回括号中的值，返回true表示打断了获取异步线程结果的操作，直接返回value值

# 2.对计算结果进行处理

#### public <U> CompletableFuture<U> thenApply(Function<? super T,? extends U> fn)

计算结果存在依赖关系，将这两个线程串行化

![](images/5.线程串行化.jpg)

**异常相关：**由于存在依赖关系（当前步错，不走下一步），当前步骤有异常的话就叫停。

#### public <U> CompletableFuture<U> handle(BiFunction<? super T, Throwable, ? extends U> fn)

计算结果存在依赖关系，将这两个线程串行化

![](images/6.handle处理线程串行化.jpg)

**异常相关：**有异常也可以往下一步走，根据带的异常参数可以进一步处理

**总结**：![](images/7.异步线程总结.jpg)











