# 多线程访问情况，3种

只有一个线程来访问，有且唯一Only One

有多个线程(2个线程A、B来交替访问）

竞争激烈，更多个线程来访问

# 升级流程

### synchronized用的锁是存在Java对象头里的Mark Word中，锁升级功能主要依赖MarkWord中锁标志位和释放偏向锁标志位

### 64位标记图再看

![image-20230730102231984](images/9.64位图.png)

### 锁指向，请牢记

偏向锁：MarkWord存储的是偏向的线程ID；

轻量锁：MarkWord存储的是指向线程栈中Lock Record的指针；

重量锁：MarkWord存储的是指向堆中的monitor对象的指针；

# 无锁

无锁：初始状态，一个对象被实例化后，如果还没有被任何线程竞争锁，那么它就为无锁状态（001）

![image-20230730141142967](images/10.无锁.png)

# 偏向锁

### 是什么

<font color = 'blue'>偏向锁：单线程竞争</font>

当线程A第一次竞争到锁时，通过操作修改Mark Word中的偏向线程ID、偏向模式。如果不存在其他线程竞争，那么持有偏向锁的线程<font color = 'red'>将永远不需要进行同步。</font>

### 主要作用

当一段同步代码一直被同一个线程多次访问，由于只有一个线程那么该线程在后续访问时便会自动获得锁

##### 小结论

Hotspot的作者经过研究发现，大多数情况下：

多线程的情况下，锁不仅不存在多线程竞争，还存在锁由同一个线程多次获得的情况，偏向锁就是在这种情况下出现的，它的出现是为了解决只有在一个线程执行同步时提高性能。

备注：

偏向锁会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。也即偏向锁在资源没有竞争情况下消除了同步语句，懒的连CAS操作都不做了，直接提高程序性能

![image-20230730143358938](images/11.偏向锁.png)

###偏向锁的持有

### 说明

<font color = 'blue'>理论落地：</font>

在实际应用运行过程中发现，“锁总是同一个线程持有，很少发生竞争”，<font color = 'red'>也就是说锁总是被第一个占用他的线程拥有，这个线程就是锁的偏向线程。</font>

那么只需要在锁第一次被拥有的时候，记录下偏向线程ID。这样偏向线程就一直持有着锁（后续这个线程进入和退出这段加了同步锁的代码块时，<font color = 'red'>不需要再次加锁和释放锁。</font>而是直接会去检查锁的MarkWord里面是不是放的自己的线程ID)。

<font color = 'red'>如果相等</font>，表示偏向锁是偏向于当前线程的，就不需要再尝试获得锁了，直到竞争发生才释放锁。以后每次同步，检查锁的偏向线程ID与当前线程ID是否一致，如果一致直接进入同步。无需每次加锁解锁都去CAS更新对象头。如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。

<font color = 'red'>如果不等</font>，表示发生了竞争，锁已经不是总是偏向于同一个线程了，这个时候会尝试使用CAS来替换MarkWord里面的线程ID为新线程的ID，
<font color = 'red'>竞争成功</font>，表示之前的线程不存在了，MarkWord里面的线程ID为新线程的ID，锁不会升级，仍然为偏向锁；
<font color = 'red'>竞争失败</font>，这时候可能需要升级变为轻量级锁，才能保证线程间公平竞争锁。
<font color = 'blue'>注意，偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的。</font>

技术实现：

一个synchronized方法被一个线程抢到了锁时，那这个方法所在的对象就会在其所在的Mark Word中将偏向锁修改状态位，同时还会有占用前54位来存储线程指针作为标识。若该线程再次访问同一个synchronized方法时，该线程只需去对象头的Mark Word 中去判断一下是否有偏向锁指向本身的ID，无需再进入Monitor去竞争对象了。









