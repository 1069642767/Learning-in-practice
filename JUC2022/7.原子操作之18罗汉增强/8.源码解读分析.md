# 小总结

LongAdder在无竞争的情况，跟AtomicLong一样，对<font color = 'red'>同一个base</font>进行操作，当出现竞争关系时则是<font color = 'red'>采用化整为零分散热点的做法</font>，用空间换时间，用一个数组cells，将一个value拆分进这个数组cells。多个线程需要同时对value进行操作时候，可以对线程id进行hash得到hash值，再根据hash值映射到这个数组cells的某个下标，再对该下标所对应的值进行自增操作。当所有线程操作完毕，将数组cells的所有值和base都加起来作为最终结果。

![image-20230715213647911](images/4.LongAdder解析.png)

# add(1L)

![image-20230715214254083](images/5.add(1L).png)

### 条件递增，逐步解析

1. 最初无竞争时只更新base；
2. 如果更新base失败后，首次新建一个cell[数组]
3. 当多个线程竞争同一个Cell比较激烈时，可能就要对Cell[]扩容

### 上述小总结

![image-20230715222347618](images/6.详解1.png)

![image-20230715222422258](images/7.详解2.png)

1如果Cells表为空，尝试用CAS更新base字段，成功则退出；

2如果Cells表为空，CAS更新base字段失败，出现竞争，uncontended为true,调用
longAccumulate;

3如果Cells表非空，但当前线程映射的槽为空，uncontended为true，调用longAccumulate;

4如果Cells表非空，且前线程映射的槽非空，CAS更新Cell的值，成功则返回，否则，
uncontended设为false,调用longAccumulate。

# longAccumulate

### longAccumulate入参说明

- longx需要增加的值，一般默认都是1
- LongBinaryOperator fn 默认传递的是null
- wasUncontended竞争标识，如果是false则代表有竞争。只有cells初始化之后，并且当前线程CAS竞争修改失败，才会是talse



# sum













