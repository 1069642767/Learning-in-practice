# 小总结

LongAdder在无竞争的情况，跟AtomicLong一样，对<font color = 'red'>同一个base</font>进行操作，当出现竞争关系时则是<font color = 'red'>采用化整为零分散热点的做法</font>，用空间换时间，用一个数组cells，将一个value拆分进这个数组cells。多个线程需要同时对value进行操作时候，可以对线程id进行hash得到hash值，再根据hash值映射到这个数组cells的某个下标，再对该下标所对应的值进行自增操作。当所有线程操作完毕，将数组cells的所有值和base都加起来作为最终结果。

![image-20230715213647911](images/4.LongAdder解析.png)

# add(1L)

![image-20230715214254083](images/5.add(1L).png)

### 条件递增，逐步解析

1. 最初无竞争时只更新base；
2. 如果更新base失败后，首次新建一个cell[数组]
3. 当多个线程竞争同一个Cell比较激烈时，可能就要对Cell[]扩容

### 上述小总结

![image-20230715222347618](images/6.详解1.png)

![image-20230715222422258](images/7.详解2.png)

1如果Cells表为空，尝试用CAS更新base字段，成功则退出；

2如果Cells表为空，CAS更新base字段失败，出现竞争，uncontended为true,调用
longAccumulate;

3如果Cells表非空，但当前线程映射的槽为空，uncontended为true，调用longAccumulate;

4如果Cells表非空，且前线程映射的槽非空，CAS更新Cell的值，成功则返回，否则，
uncontended设为false,调用longAccumulate。

# longAccumulate

### longAccumulate入参说明

- longx需要增加的值，一般默认都是1
- LongBinaryOperator fn 默认传递的是null
- wasUncontended竞争标识，如果是false则代表有竞争。只有cells初始化之后，并且当前线程CAS竞争修改失败，才会是talse

###  Striped64中一些变量或者方法的定义

- base：类似于AtomicLong中全局的value值。在没有竞争情况下数据直接累加到base上，或者cells扩容时，也需要将数据写入到base上
- collide：表示扩容意向，false一定不会扩容，true可能会扩容。
- cellsBusy：初始化cells或者扩容cells需要获取锁，0：表示无锁状态1:表示其他线程已经持有了锁
- casCellsBusy()：通过CAS操作修改cellsBusy的值，CAS成功代表获取锁，返回true
- NCPU：当前计算机CPU数量，Cell数组扩容时会使用到
- getProbe()：获取当前线程的hash值
- advanceProbe()：重置当前线程的hash值



### 步骤

### 线程hash值：probe

![image-20230716102543655](images/8.probe()初始化.png)

![image-20230716103102766](images/9.probe()初始化.png)

### 总纲

![image-20230716103935430](F:\workspace\数据结构和算法\Learning-in-practice\JUC2022\10.自旋.png)







# sum













